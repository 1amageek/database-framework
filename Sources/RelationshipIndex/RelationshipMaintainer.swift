// RelationshipMaintainer.swift
// RelationshipIndex - Maintains relationship indexes and enforces delete rules

import Foundation
import Core
import Relationship
import DatabaseEngine
import FoundationDB

/// Enforces delete rules for relationships
///
/// `RelationshipMaintainer` handles:
/// - Delete rule enforcement (cascade, nullify, deny, noAction)
/// - Finding related items via relationship indexes
///
/// **Note**: Relationship index updates are handled automatically by `FDBContext.updateIndexes()`
/// using the ScalarIndex generated by `@Relationship` macro. This class is only responsible
/// for delete rule enforcement.
///
/// **Relationship Index Structure** (managed by ScalarIndex via @Relationship macro):
/// ```
/// [fdb]/I/[Type]_[property]/[relatedId]/[ownerId] = empty
/// ```
///
/// **Example**:
/// ```
/// [fdb]/I/Order_customer/["C001"]/["O001"] = ''
/// [fdb]/I/Order_customer/["C001"]/["O002"] = ''
/// ```
///
/// **Delete Rule Enforcement**:
/// - `.cascade`: Delete all related items
/// - `.deny`: Throw error if related items exist
/// - `.nullify`: Set related items' foreign keys to nil
/// - `.noAction`: Do nothing (may leave orphans)
///
/// **Usage**:
/// ```swift
/// let maintainer = RelationshipMaintainer(container: container, schema: schema)
/// let handler = context.makePersistenceHandler()
///
/// try await maintainer.enforceDeleteRules(
///     for: customer,
///     transaction: transaction,
///     handler: handler
/// )
/// ```
public final class RelationshipMaintainer: Sendable {
    // MARK: - Properties

    /// FDB Container for resolving type directories
    private let container: FDBContainer

    /// Schema containing type definitions
    private let schema: Schema

    // MARK: - Initialization

    /// Initialize relationship maintainer
    ///
    /// - Parameters:
    ///   - container: FDB Container for resolving type directories
    ///   - schema: Schema containing type definitions and relationships
    public init(
        container: FDBContainer,
        schema: Schema
    ) {
        self.container = container
        self.schema = schema
    }

    // MARK: - Delete Rule Enforcement

    /// Enforce delete rules before deleting an item
    ///
    /// Called before an item is deleted to handle relationships.
    /// Checks all types that have relationships pointing to this item
    /// and enforces their delete rules.
    ///
    /// - Parameters:
    ///   - item: The item being deleted
    ///   - transaction: FDB transaction
    ///   - handler: ModelPersistenceHandler for save/delete/load operations
    ///   - recursiveDeleter: Optional closure for recursive deletes (cascade)
    public func enforceDeleteRules(
        for item: any Persistable,
        transaction: any TransactionProtocol,
        handler: ModelPersistenceHandler,
        recursiveDeleter: (@Sendable (any Persistable, any TransactionProtocol) async throws -> Void)? = nil
    ) async throws {
        // Start with empty visited set for cycle detection
        var visited = Set<String>()
        try await enforceDeleteRules(
            for: item,
            transaction: transaction,
            handler: handler,
            recursiveDeleter: recursiveDeleter,
            visited: &visited
        )
    }

    /// Enforce delete rules with cycle detection
    ///
    /// **Cycle Detection**:
    /// Tracks visited items to prevent infinite loops during cascade deletes.
    /// If an item has already been visited in this delete chain, it's skipped.
    ///
    /// **Example Cycle**:
    /// ```
    /// A.cascade → B.cascade → A (detected and skipped)
    /// ```
    ///
    /// - Parameters:
    ///   - item: The item being deleted
    ///   - transaction: FDB transaction
    ///   - handler: ModelPersistenceHandler for save/delete/load operations
    ///   - recursiveDeleter: Optional closure for recursive deletes (cascade)
    ///   - visited: Set of visited item keys (type:id) for cycle detection
    public func enforceDeleteRules(
        for item: any Persistable,
        transaction: any TransactionProtocol,
        handler: ModelPersistenceHandler,
        recursiveDeleter: (@Sendable (any Persistable, any TransactionProtocol) async throws -> Void)?,
        visited: inout Set<String>
    ) async throws {
        let itemType = type(of: item)
        let itemTypeName = itemType.persistableType
        let itemId = try extractItemId(from: item)

        // Create unique key for this item
        let itemKey = makeItemKey(typeName: itemTypeName, id: itemId)

        // Cycle detection: skip if already visited
        if visited.contains(itemKey) {
            return
        }
        visited.insert(itemKey)

        // Find all relationships that point TO this type
        // Iterate over all entities in the schema
        for entity in schema.entities {
            // Get relationship descriptors from the persistable type
            let relationshipDescriptors = entity.persistableType.relationshipDescriptors

            for descriptor in relationshipDescriptors {
                // Check if this relationship points to the item being deleted
                guard descriptor.relatedTypeName == itemTypeName else { continue }

                // This type has a relationship to the item being deleted
                // Enforce the delete rule (passing visited set for cycle detection)
                try await enforceDeleteRuleWithCycleDetection(
                    descriptor: descriptor,
                    owningTypeName: entity.name,
                    owningType: entity.persistableType,
                    relatedItemId: itemId,
                    transaction: transaction,
                    handler: handler,
                    recursiveDeleter: recursiveDeleter,
                    visited: &visited
                )
            }
        }
    }

    /// Create unique key for item (used in visited set)
    private func makeItemKey(typeName: String, id: Tuple) -> String {
        "\(typeName):\(id.pack().map { String(format: "%02x", $0) }.joined())"
    }

    /// Enforce a specific delete rule
    private func enforceDeleteRule(
        descriptor: RelationshipDescriptor,
        owningTypeName: String,
        owningType: any Persistable.Type,
        relatedItemId: Tuple,
        transaction: any TransactionProtocol,
        handler: ModelPersistenceHandler,
        recursiveDeleter: (@Sendable (any Persistable, any TransactionProtocol) async throws -> Void)?
    ) async throws {
        // Resolve the owning type's directory (not the deleted item's directory)
        let owningSubspace = try await container.resolveDirectory(for: owningType)
        let owningIndexSubspace = owningSubspace.subspace(SubspaceKey.indexes)

        // Use descriptor.name directly (e.g., "Order_customer")
        // Note: The index name is "{OwnerType}_{relationshipPropertyName}", not "{OwnerType}_{propertyName}"
        let relIndexSubspace = owningIndexSubspace.subspace(descriptor.name)
        let prefixSubspace = relIndexSubspace.subspace(relatedItemId)

        let (begin, end) = prefixSubspace.range()
        let sequence = transaction.getRange(begin: begin, end: end, snapshot: false)

        var affectedItemIds: [Tuple] = []
        for try await (key, _) in sequence {
            if let ownerId = extractOwnerIdFromRelationshipKey(key, prefixSubspace: prefixSubspace) {
                affectedItemIds.append(ownerId)
            }
        }

        // If no affected items, nothing to do
        guard !affectedItemIds.isEmpty else { return }

        // Apply delete rule
        switch descriptor.deleteRule {
        case .cascade:
            // Delete all related items
            for ownerId in affectedItemIds {
                if let owningItem = try await handler.load(owningTypeName, id: ownerId, transaction: transaction) {
                    // Use recursive deleter if provided (for cascading relationship rule enforcement)
                    if let recursiveDeleter = recursiveDeleter {
                        try await recursiveDeleter(owningItem, transaction)
                    } else {
                        try await handler.delete(owningItem, transaction: transaction)
                    }
                }
            }

        case .deny:
            // Throw error if related items exist
            throw RelationshipError.deleteRuleDenied(
                itemType: descriptor.relatedTypeName,
                relationshipType: owningTypeName,
                propertyName: descriptor.propertyName,
                count: affectedItemIds.count
            )

        case .nullify:
            // Nullify: Set FK field to nil and clear relationship index
            let foreignKeyFieldName = descriptor.propertyName

            for ownerId in affectedItemIds {
                // Load the owning item
                guard let owningItem = try await handler.load(owningTypeName, id: ownerId, transaction: transaction) else {
                    continue
                }

                // Nullify the FK field and save
                if let nullifiedItem = try nullifyForeignKey(owningItem, fieldName: foreignKeyFieldName) {
                    try await handler.save(nullifiedItem, transaction: transaction)
                }
            }

        case .noAction:
            // Do nothing - may leave orphan references
            break
        }
    }

    /// Enforce a specific delete rule with cycle detection
    ///
    /// Similar to `enforceDeleteRule` but tracks visited items to prevent
    /// infinite loops during cascade deletes.
    ///
    /// - Parameters:
    ///   - descriptor: The relationship descriptor
    ///   - owningTypeName: Name of the type that owns the relationship
    ///   - owningType: The Persistable type that owns the relationship
    ///   - relatedItemId: ID of the item being deleted
    ///   - transaction: FDB transaction
    ///   - handler: ModelPersistenceHandler for save/delete/load operations
    ///   - recursiveDeleter: Optional closure for recursive deletes (cascade)
    ///   - visited: Set of visited item keys for cycle detection
    private func enforceDeleteRuleWithCycleDetection(
        descriptor: RelationshipDescriptor,
        owningTypeName: String,
        owningType: any Persistable.Type,
        relatedItemId: Tuple,
        transaction: any TransactionProtocol,
        handler: ModelPersistenceHandler,
        recursiveDeleter: (@Sendable (any Persistable, any TransactionProtocol) async throws -> Void)?,
        visited: inout Set<String>
    ) async throws {
        // Resolve the owning type's directory (not the deleted item's directory)
        let owningSubspace = try await container.resolveDirectory(for: owningType)
        let owningIndexSubspace = owningSubspace.subspace(SubspaceKey.indexes)

        // Use descriptor.name directly (e.g., "Order_customer")
        let relIndexSubspace = owningIndexSubspace.subspace(descriptor.name)
        let prefixSubspace = relIndexSubspace.subspace(relatedItemId)

        let (begin, end) = prefixSubspace.range()
        let sequence = transaction.getRange(begin: begin, end: end, snapshot: false)

        var affectedItemIds: [Tuple] = []
        for try await (key, _) in sequence {
            if let ownerId = extractOwnerIdFromRelationshipKey(key, prefixSubspace: prefixSubspace) {
                affectedItemIds.append(ownerId)
            }
        }

        // If no affected items, nothing to do
        guard !affectedItemIds.isEmpty else { return }

        // Apply delete rule
        switch descriptor.deleteRule {
        case .cascade:
            // Delete all related items with cycle detection
            for ownerId in affectedItemIds {
                // Create unique key for this owning item
                let owningItemKey = makeItemKey(typeName: owningTypeName, id: ownerId)

                // Skip if already visited (cycle detected)
                if visited.contains(owningItemKey) {
                    continue
                }

                if let owningItem = try await handler.load(owningTypeName, id: ownerId, transaction: transaction) {
                    // Mark as visited before processing
                    visited.insert(owningItemKey)

                    // Use recursive deleter if provided (for cascading relationship rule enforcement)
                    if let recursiveDeleter = recursiveDeleter {
                        try await recursiveDeleter(owningItem, transaction)
                    } else {
                        // First enforce delete rules for this item (with cycle detection)
                        try await enforceDeleteRules(
                            for: owningItem,
                            transaction: transaction,
                            handler: handler,
                            recursiveDeleter: recursiveDeleter,
                            visited: &visited
                        )
                        // Then delete the item
                        try await handler.delete(owningItem, transaction: transaction)
                    }
                }
            }

        case .deny:
            // Throw error if related items exist
            throw RelationshipError.deleteRuleDenied(
                itemType: descriptor.relatedTypeName,
                relationshipType: owningTypeName,
                propertyName: descriptor.propertyName,
                count: affectedItemIds.count
            )

        case .nullify:
            // Nullify: Set FK field to nil and clear relationship index
            let foreignKeyFieldName = descriptor.propertyName

            for ownerId in affectedItemIds {
                // Load the owning item
                guard let owningItem = try await handler.load(owningTypeName, id: ownerId, transaction: transaction) else {
                    continue
                }

                // Nullify the FK field and save
                if let nullifiedItem = try nullifyForeignKey(owningItem, fieldName: foreignKeyFieldName) {
                    try await handler.save(nullifiedItem, transaction: transaction)
                }
            }

        case .noAction:
            // Do nothing - may leave orphan references
            break
        }
    }

    // MARK: - Related Item Loading

    /// Find items that reference a given item via a relationship
    ///
    /// Used to find all items with a to-one relationship pointing to the target.
    ///
    /// - Parameters:
    ///   - targetId: ID of the target item being referenced
    ///   - owningType: Type that owns the relationship
    ///   - descriptor: The relationship descriptor
    ///   - transaction: FDB transaction
    /// - Returns: Array of item IDs that reference the target
    public func findReferringItemIds(
        targetId: Tuple,
        owningType: any Persistable.Type,
        descriptor: RelationshipDescriptor,
        transaction: any TransactionProtocol
    ) async throws -> [Tuple] {
        // Resolve the owning type's directory
        let owningSubspace = try await container.resolveDirectory(for: owningType)
        let owningIndexSubspace = owningSubspace.subspace(SubspaceKey.indexes)

        // Use descriptor.name directly (e.g., "Order_customer")
        let relIndexSubspace = owningIndexSubspace.subspace(descriptor.name)
        let prefixSubspace = relIndexSubspace.subspace(targetId)

        let (begin, end) = prefixSubspace.range()
        let sequence = transaction.getRange(begin: begin, end: end, snapshot: false)

        var itemIds: [Tuple] = []
        for try await (key, _) in sequence {
            if let ownerId = extractOwnerIdFromRelationshipKey(key, prefixSubspace: prefixSubspace) {
                itemIds.append(ownerId)
            }
        }

        return itemIds
    }

    // MARK: - Private Helpers

    /// Extract item ID as Tuple
    private func extractItemId(from item: any Persistable) throws -> Tuple {
        let id = item.id
        if let tupleElement = id as? any TupleElement {
            return Tuple([tupleElement])
        }
        // Fallback: convert to string
        return Tuple([String(describing: id)])
    }

    /// Extract owner ID from relationship index key
    private func extractOwnerIdFromRelationshipKey(
        _ key: [UInt8],
        prefixSubspace: Subspace
    ) -> Tuple? {
        do {
            let tuple = try prefixSubspace.unpack(key)
            if tuple.count > 0 {
                return tuple
            }
        } catch {
            // Key doesn't match expected format
        }
        return nil
    }

    /// Nullify a foreign key field using JSON round-trip
    private func nullifyForeignKey(
        _ item: any Persistable,
        fieldName: String
    ) throws -> (any Persistable)? {
        let itemType = type(of: item)

        // Encode to JSON
        let jsonEncoder = JSONEncoder()
        let jsonData = try jsonEncoder.encode(item)

        // Parse as dictionary
        guard var dict = try JSONSerialization.jsonObject(with: jsonData) as? [String: Any] else {
            return nil
        }

        // Remove the FK field (setting to nil for Optional fields)
        dict.removeValue(forKey: fieldName)

        // Re-encode to JSON data
        let modifiedJsonData = try JSONSerialization.data(withJSONObject: dict)

        // Decode back to the original type
        let jsonDecoder = JSONDecoder()
        return try jsonDecoder.decode(itemType, from: modifiedJsonData)
    }
}

// MARK: - Relationship Errors

/// Errors that can occur during relationship operations
public enum RelationshipError: Error, CustomStringConvertible {
    /// Delete was denied due to existing related items
    case deleteRuleDenied(
        itemType: String,
        relationshipType: String,
        propertyName: String,
        count: Int
    )

    /// Related item not found
    case relatedItemNotFound(
        itemType: String,
        relatedType: String,
        relatedId: String
    )

    /// Invalid relationship configuration
    case invalidConfiguration(message: String)

    public var description: String {
        switch self {
        case .deleteRuleDenied(let itemType, let relationshipType, let propertyName, let count):
            return "Cannot delete \(itemType): \(count) \(relationshipType) item(s) reference it via '\(propertyName)' with deleteRule=.deny"
        case .relatedItemNotFound(let itemType, let relatedType, let relatedId):
            return "Related \(relatedType) with id '\(relatedId)' not found for \(itemType)"
        case .invalidConfiguration(let message):
            return "Invalid relationship configuration: \(message)"
        }
    }
}
