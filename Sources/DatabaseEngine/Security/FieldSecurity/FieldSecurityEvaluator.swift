// FieldSecurityEvaluator.swift
// DatabaseEngine - Evaluator for field-level security

import Foundation
import Core

/// Evaluator for field-level security
///
/// Provides methods to:
/// - Extract restricted field metadata from a type
/// - Mask fields that the user cannot read
/// - Validate write permissions before save
///
/// **Usage**:
/// ```swift
/// let auth = MyAuth(userID: "user-1", roles: ["employee"])
///
/// // Mask fields user cannot read
/// let masked = FieldSecurityEvaluator.mask(employee, auth: auth)
///
/// // Validate write permissions
/// try FieldSecurityEvaluator.validateWrite(
///     original: existingEmployee,
///     updated: modifiedEmployee,
///     auth: auth
/// )
/// ```
public struct FieldSecurityEvaluator {

    // MARK: - Field Metadata Extraction

    /// Information about a restricted field (for internal use)
    public struct RestrictedFieldInfo: Sendable {
        public let fieldName: String
        public let readAccess: FieldAccessLevel
        public let writeAccess: FieldAccessLevel
    }

    /// Extract restricted field information from a Persistable type
    ///
    /// Uses static metadata generated by @Persistable macro.
    ///
    /// - Parameter type: The Persistable type to inspect
    /// - Returns: Dictionary of field name to restriction info
    public static func extractRestrictedFields<T: Persistable>(for type: T.Type) -> [String: RestrictedFieldInfo] {
        var result: [String: RestrictedFieldInfo] = [:]

        for metadata in type.restrictedFieldsMetadata {
            result[metadata.fieldName] = RestrictedFieldInfo(
                fieldName: metadata.fieldName,
                readAccess: metadata.readAccess,
                writeAccess: metadata.writeAccess
            )
        }

        return result
    }

    /// Extract restricted field information from a value
    ///
    /// For Persistable types, uses static metadata (preferred).
    /// For other types, falls back to runtime reflection (deprecated).
    ///
    /// - Parameter value: The value to inspect
    /// - Returns: Dictionary of field name to restriction info
    public static func extractRestrictedFields<T>(from value: T) -> [String: RestrictedFieldInfo] {
        // For Persistable types, use static metadata
        if let persistable = value as? any Persistable {
            return extractRestrictedFieldsFromPersistable(persistable)
        }

        // Fallback to reflection for non-Persistable types
        return extractRestrictedFieldsViaReflection(from: value)
    }

    /// Internal helper to extract from Persistable using static metadata
    private static func extractRestrictedFieldsFromPersistable(_ value: any Persistable) -> [String: RestrictedFieldInfo] {
        var result: [String: RestrictedFieldInfo] = [:]

        for metadata in type(of: value).restrictedFieldsMetadata {
            result[metadata.fieldName] = RestrictedFieldInfo(
                fieldName: metadata.fieldName,
                readAccess: metadata.readAccess,
                writeAccess: metadata.writeAccess
            )
        }

        return result
    }

    /// Fallback: Extract via reflection (for non-Persistable types)
    ///
    /// **Warning**: This approach has limitations:
    /// - Access levels are lost after Codable decode
    /// - Only works if the property wrapper storage is accessible
    private static func extractRestrictedFieldsViaReflection<T>(from value: T) -> [String: RestrictedFieldInfo] {
        var result: [String: RestrictedFieldInfo] = [:]
        let mirror = Mirror(reflecting: value)

        for child in mirror.children {
            guard var label = child.label else { continue }

            if let restricted = child.value as? any RestrictedProtocol {
                if label.hasPrefix("_") {
                    label = String(label.dropFirst())
                }

                result[label] = RestrictedFieldInfo(
                    fieldName: label,
                    readAccess: restricted.readAccess,
                    writeAccess: restricted.writeAccess
                )
            }
        }

        return result
    }

    // MARK: - Read Access Evaluation

    /// Check if a field can be read
    ///
    /// - Parameters:
    ///   - fieldName: Name of the field
    ///   - value: The object containing the field
    ///   - auth: Authentication context (nil = unauthenticated)
    /// - Returns: true if read is allowed
    public static func canRead<T>(
        field fieldName: String,
        in value: T,
        auth: (any AuthContext)?
    ) -> Bool {
        let restrictions = extractRestrictedFields(from: value)

        guard let info = restrictions[fieldName] else {
            return true // No restriction = public access
        }

        return info.readAccess.evaluate(auth: auth)
    }

    /// Check if a field can be read (type-based)
    ///
    /// - Parameters:
    ///   - fieldName: Name of the field
    ///   - type: The Persistable type
    ///   - auth: Authentication context (nil = unauthenticated)
    /// - Returns: true if read is allowed
    public static func canRead<T: Persistable>(
        field fieldName: String,
        in type: T.Type,
        auth: (any AuthContext)?
    ) -> Bool {
        let restrictions = extractRestrictedFields(for: type)

        guard let info = restrictions[fieldName] else {
            return true // No restriction = public access
        }

        return info.readAccess.evaluate(auth: auth)
    }

    /// Get list of fields that cannot be read
    ///
    /// - Parameters:
    ///   - value: The object to check
    ///   - auth: Authentication context
    /// - Returns: List of field names that cannot be read
    public static func unreadableFields<T>(
        in value: T,
        auth: (any AuthContext)?
    ) -> [String] {
        let restrictions = extractRestrictedFields(from: value)

        return restrictions.compactMap { fieldName, info in
            info.readAccess.evaluate(auth: auth) ? nil : fieldName
        }
    }

    /// Get list of fields that cannot be read (type-based)
    ///
    /// - Parameters:
    ///   - type: The Persistable type
    ///   - auth: Authentication context
    /// - Returns: List of field names that cannot be read
    public static func unreadableFields<T: Persistable>(
        in type: T.Type,
        auth: (any AuthContext)?
    ) -> [String] {
        let restrictions = extractRestrictedFields(for: type)

        return restrictions.compactMap { fieldName, info in
            info.readAccess.evaluate(auth: auth) ? nil : fieldName
        }
    }

    // MARK: - Write Access Evaluation

    /// Check if a field can be written
    ///
    /// - Parameters:
    ///   - fieldName: Name of the field
    ///   - value: The object containing the field
    ///   - auth: Authentication context (nil = unauthenticated)
    /// - Returns: true if write is allowed
    public static func canWrite<T>(
        field fieldName: String,
        in value: T,
        auth: (any AuthContext)?
    ) -> Bool {
        let restrictions = extractRestrictedFields(from: value)

        guard let info = restrictions[fieldName] else {
            return true // No restriction = public access
        }

        return info.writeAccess.evaluate(auth: auth)
    }

    /// Check if a field can be written (type-based)
    ///
    /// - Parameters:
    ///   - fieldName: Name of the field
    ///   - type: The Persistable type
    ///   - auth: Authentication context (nil = unauthenticated)
    /// - Returns: true if write is allowed
    public static func canWrite<T: Persistable>(
        field fieldName: String,
        in type: T.Type,
        auth: (any AuthContext)?
    ) -> Bool {
        let restrictions = extractRestrictedFields(for: type)

        guard let info = restrictions[fieldName] else {
            return true // No restriction = public access
        }

        return info.writeAccess.evaluate(auth: auth)
    }

    /// Get list of fields that cannot be written
    ///
    /// - Parameters:
    ///   - value: The object to check
    ///   - auth: Authentication context
    /// - Returns: List of field names that cannot be written
    public static func unwritableFields<T>(
        in value: T,
        auth: (any AuthContext)?
    ) -> [String] {
        let restrictions = extractRestrictedFields(from: value)

        return restrictions.compactMap { fieldName, info in
            info.writeAccess.evaluate(auth: auth) ? nil : fieldName
        }
    }

    /// Get list of fields that cannot be written (type-based)
    ///
    /// - Parameters:
    ///   - type: The Persistable type
    ///   - auth: Authentication context
    /// - Returns: List of field names that cannot be written
    public static func unwritableFields<T: Persistable>(
        in type: T.Type,
        auth: (any AuthContext)?
    ) -> [String] {
        let restrictions = extractRestrictedFields(for: type)

        return restrictions.compactMap { fieldName, info in
            info.writeAccess.evaluate(auth: auth) ? nil : fieldName
        }
    }

    // MARK: - Masking

    /// Mask fields that cannot be read by setting them to default values
    ///
    /// Uses the macro-generated `masked(auth:)` method for Persistable types.
    ///
    /// - Parameters:
    ///   - value: The value to mask
    ///   - auth: Authentication context
    /// - Returns: Masked copy of the value
    public static func mask<T: Persistable>(
        _ value: T,
        auth: (any AuthContext)?
    ) -> T {
        // Use macro-generated masked(auth:) method
        return value.masked(auth: auth)
    }

    /// Mask multiple values
    ///
    /// - Parameters:
    ///   - values: Array of values to mask
    ///   - auth: Authentication context
    /// - Returns: Array of masked values
    public static func mask<T: Persistable>(
        _ values: [T],
        auth: (any AuthContext)?
    ) -> [T] {
        values.map { $0.masked(auth: auth) }
    }

    // MARK: - Write Validation

    /// Validate that the user has permission to write changed fields
    ///
    /// Compares original and updated values, and checks write permission
    /// for any fields that have changed.
    ///
    /// - Parameters:
    ///   - original: Original value (nil for new inserts)
    ///   - updated: Updated value to be saved
    ///   - auth: Authentication context
    /// - Throws: FieldSecurityError.writeNotAllowed if any changed field cannot be written
    public static func validateWrite<T: Persistable>(
        original: T?,
        updated: T,
        auth: (any AuthContext)?
    ) throws {
        let restrictions = extractRestrictedFields(for: T.self)

        if restrictions.isEmpty {
            return // No restricted fields
        }

        var violations: [String] = []

        for (fieldName, info) in restrictions {
            // Check if user can write this field
            if !info.writeAccess.evaluate(auth: auth) {
                // Check if field has changed
                if let original = original {
                    if fieldChanged(original: original, updated: updated, fieldName: fieldName) {
                        violations.append(fieldName)
                    }
                } else {
                    // New insert - check if value is non-default
                    if !isDefaultValue(in: updated, fieldName: fieldName) {
                        violations.append(fieldName)
                    }
                }
            }
        }

        if !violations.isEmpty {
            throw FieldSecurityError.writeNotAllowed(
                type: T.persistableType,
                fields: violations.sorted()
            )
        }
    }

    /// Validate write for multiple values
    ///
    /// - Parameters:
    ///   - originals: Dictionary of ID to original value
    ///   - updates: Array of updated values
    ///   - auth: Authentication context
    /// - Throws: FieldSecurityError.writeNotAllowed
    public static func validateWrite<T: Persistable>(
        originals: [String: T],
        updates: [T],
        auth: (any AuthContext)?
    ) throws {
        for updated in updates {
            let original = originals["\(updated.id)"]
            try validateWrite(original: original, updated: updated, auth: auth)
        }
    }

    // MARK: - Private Helpers

    /// Check if a field has changed between original and updated
    private static func fieldChanged<T: Persistable>(
        original: T,
        updated: T,
        fieldName: String
    ) -> Bool {
        // Use dynamicMember subscript for field access
        let originalValue = original[dynamicMember: fieldName]
        let updatedValue = updated[dynamicMember: fieldName]

        // Compare using string representation as fallback
        return "\(originalValue ?? "nil")" != "\(updatedValue ?? "nil")"
    }

    /// Check if a field has its default/zero value
    private static func isDefaultValue<T: Persistable>(in value: T, fieldName: String) -> Bool {
        guard let fieldValue = value[dynamicMember: fieldName] else {
            return true // nil = default for Optional fields
        }

        // Check common default values
        switch fieldValue {
        case let str as String where str.isEmpty:
            return true
        case let num as Int where num == 0:
            return true
        case let num as Int64 where num == 0:
            return true
        case let num as Double where num == 0:
            return true
        case let num as Float where num == 0:
            return true
        case let bool as Bool where bool == false:
            return true
        case let arr as [Any] where arr.isEmpty:
            return true
        case let data as Data where data.isEmpty:
            return true
        default:
            return false
        }
    }
}
